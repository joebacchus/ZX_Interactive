<!DOCTYPE html>
<html>
<head>
    <title>Starting</title>
    <link rel="stylesheet" href="sandboxDemo.css">
<!-- Load the Paper.js library -->
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.15/paper-full.min.js"></script>
<!-- Define inlined PaperScript associate it with myCanvas -->
<script type="text/paperscript" canvas="myCanvas">
// Colors
var red_color = "#ff3657";
var green_color = "#8dff36";
var black_color = "#242424";
var black_color_h = "#575757";
var grid_dot_color = "#000000"; // Color for grid dots

// Grid size
var gridSize = 20; // Change this value to adjust the grid cell size
var gridDotRadius = 1; // Radius of the grid dots

// Grid dimensions (fixed size)
var gridWidth = 500; // Width of the grid
var gridHeight = 500; // Height of the grid

// Calculate center position
var centerX = view.size.width / 2;
var centerY = view.size.height / 2;

// Create layers
var backgroundLayer = new Layer(); // Layer for grid dots
var foregroundLayer = new Layer(); // Default layer for other elements
var textLayer = new Layer(); // Layer for the plus symbols

// Initial circles
var Z_spi_init = new Path.Circle({
    center: [centerX - 0, centerY - 0], // Adjust initial position as needed
    radius: 8,
    strokeColor: black_color,
    strokeWidth: 2,
    fillColor: green_color,
    parent: foregroundLayer // Add to the foreground layer
});

var X_spi_init = new Path.Circle({
    center: [centerX - 0, centerY + 0], // Adjust initial position as needed
    radius: 8,
    strokeColor: black_color,
    strokeWidth: 2,
    fillColor: red_color,
    parent: foregroundLayer // Add to the foreground layer
});
// Cable box
var string_rect = new Path.Rectangle({
    point: [centerX - 290, centerY + 50], // Top-left corner
    size: [25, 25], // Width and height
    strokeColor: black_color, // Black border
    strokeWidth: 1, // Border width
    fillColor: 'white', // Completely transparent fill
        });
string_rect.smooth({ type: 'geometric', factor: 0.05 });
// dynamic string icon
string_rect.onMouseEnter = function(event) {
    spline.visible = true;
};
string_rect.onMouseLeave = function(event) {
    spline.visible = false;
};
    
string_rect.onClick = function(event) {
    drawingActive = !drawingActive
}

// Plus symbols
var Z_spi_plus = new PointText({
    point: Z_spi_init.position,
    content: '+',
    fillColor: black_color,
    fontSize: 15,
    fontFamily: 'Arial',
    parent: textLayer // Add to the text layer
});
Z_spi_plus.visible = false; // Initially hidden

var X_spi_plus = new PointText({
    point: X_spi_init.position,
    content: '+',
    fillColor: black_color,
    fontSize: 15,
    fontFamily: 'Arial',
    parent: textLayer // Add to the text layer
});
X_spi_plus.visible = false; // Initially hidden

// Create string icon
var spline = new Path({
    strokeColor: 'black',
    strokeWidth: 1,
    parent: textLayer
});
// 4 points to the path
spline.add(new Point(string_rect.position.x - 20, string_rect.position.y - 20));
spline.add(new Point(string_rect.position.x - 10, string_rect.position.y - 17));
spline.add(new Point(string_rect.position.x - 15, string_rect.position.y - 11));
spline.add(new Point(string_rect.position.x - 5, string_rect.position.y - 5));
spline.smooth();
spline.visible = false;
spline.fullySelected = false; // Prevent it from being selected
spline.guide = true; // Make it a non-interactive guide path (optional)
spline.ignoreEvents = true; // Disable hit testing for this path

var spiders = [];
var splines_points = [];
var spi_cen_pos = []; // position from centre for resizing
var active_spi = null;
var activePath = null;
var Z_spi_selected = false;
var X_spi_selected = false;
var drawingActive = false;
var strings = [];
var draggingPoint = null; // for string points

// Create grid dots
function createGridDots() {
    backgroundLayer.removeChildren(); // Clear existing grid dots
    
    var startX = centerX - gridWidth / 2;
    var startY = centerY - gridHeight / 2;

    for (var x = startX; x < startX + gridWidth; x += gridSize) {
        for (var y = startY; y < startY + gridHeight; y += gridSize) {
            new Path.Circle({
                center: [x, y],
                radius: gridDotRadius,
                fillColor: grid_dot_color,
                parent: backgroundLayer // Add to the background layer
            });
        }
    }
}

function onResize(event) {
    // Recalculate center position
    centerX = view.size.width / 2;
    centerY = view.size.height / 2;

    // Center initial spiders
    Z_spi_init.position = [centerX - 290, centerY - 30];
    X_spi_init.position = [centerX - 290, centerY + 10];
    string_rect.position = [centerX - 290, centerY + 50];
    spline.position = [centerX - 290, centerY + 50];
    
    // Update plus symbols position
    Z_spi_plus.position = Z_spi_init.position;
    X_spi_plus.position = X_spi_init.position;
    
    // Recreate grid dots
    createGridDots();
    
    // centre placed spiders
    for (var i = 0; i < spi_cen_pos.length; i++) {
        spiders[i].position = spi_cen_pos[i] + view.center
        }
}
var spl_index = null; pt=index = null;
function onMouseDown(event) {
    // Check if any existing circle is clicked
    for (var i = 0; i < spiders.length; i++) {
        var circle = spiders[i];
        if (circle.contains(event.point)) {
            // Start dragging the clicked circle
            active_spi = circle;
            active_spi.dragging = true;
            active_spi.lastPoint = event.point; // Store the last point
            return;
        }
    }
    // Check if the user clicked on any of the point circles
    //console.log(splines_points.length);
    for (var i = 0; i < splines_points.length; i++) {
        //console.log(spl_points)
        //console.log("Spline ${i + 1}:");
        for (var j = 0; j < splines_points[i].length; j++) {
            //console.log(j);
            if (splines_points[i][j].hitTest(event.point)) {
                draggingPoint = splines_points[i][j]; // Set the point that is being dragged-->
                spl_index = i;
                pt_index = j;
                break;
            }
        }
    }

    // If the green initial circle is clicked, create a new circle
    if (Z_spi_init.contains(event.point)) {
        active_spi = new Path.Circle({
            center: snapToGrid(event.point),
            radius: 8,
            strokeColor: black_color,
            strokeWidth: 2,
            fillColor: green_color,
        });
        spiders.push(active_spi); // Add the new circle to the array
        spi_cen_pos.push(active_spi.position - view.center)
        active_spi.dragging = true;
    }

    // If the red initial circle is clicked, create a new circle
    else if (X_spi_init.contains(event.point)) {
        active_spi = new Path.Circle({
            center: snapToGrid(event.point),
            radius: 8,
            strokeColor: black_color,
            strokeWidth: 2,
            fillColor: red_color,
        });
        spiders.push(active_spi); // Add the new circle to the array
        spi_cen_pos.push(active_spi.position - view.center)
        active_spi.dragging = true;
    }
    else {
        // If clicking elsewhere and there's an active circle, stop dragging
        if (active_spi) {
            active_spi.dragging = false;
            active_spi = null;
        }
    }
}

function onMouseDrag(event) {
    // If an active circle is being dragged, move it to the snapped cursor position
    if (active_spi && active_spi.dragging) {
        // Snap the cursor position to the grid
        var snappedPoint = snapToGrid(event.point+[10,10]);
        active_spi.position = snappedPoint;
        for (var i = 0; i < spi_cen_pos.length; i++) {
            spi_cen_pos[i] = spiders[i].position - view.center // update centred
        
        }
    }
    if (draggingPoint) {
        // Move the point being dragged
        draggingPoint.position = snapToGrid(event.point + [10,10]);
        strings[spl_index].segments[pt_index].point = draggingPoint.position;
        
    }
}
// drawing function
view.onClick = function(event) {
    var hitResult = project.hitTest(event.point); // ensure pen does not activate ontop of another object
    if (drawingActive && !activePath && !hitResult) {
        // Create a new path and add the initial point, snapped to the grid
        activePath = new Path({
            strokeColor: black_color,
            strokeWidth: 2
        });
        activePath.add(snapToGrid(event.point+[10,10]));
    } else if (drawingActive && activePath) { // If drawing is active, add the final point, snapped to the grid, and stop drawing
        activePath.add(snapToGrid(event.point+[10,10]));
        // simplifying the string by replacing with an N point spline
        var splinePath = new Path({
            strokeColor: black_color,
            strokeWidth: 2
        });
        var k = 0.01; // node density
        var N = Math.floor(k * activePath.length); // Number of nodes on final spline
        var spl_points = []; // to temporarily save spline nodes
        for (var i = 0; i <= N; i++) {
            var offset = (i / N) * activePath.length; // offset along the path
            var point = activePath.getPointAt(offset); // point at offset
            var snapd_point = snapToGrid(point) // snap spline points to grid
            splinePath.add(snapd_point);
            // Create a circle at each node / point
            var pointCircle = new Path.Circle({
                center: snapd_point,
                radius: 3,
                fillColor: 'white',
                strokeColor: black_color,
                strokeWidth: 3
            });
            pointCircle.sendToBack();
            spl_points.push(pointCircle); // Store
        }
        activePath.remove(); activePath = null;
        splinePath.sendToBack(); splinePath.smooth(); // strings below spiders
        splines_points.push(spl_points);
        strings.push(splinePath);
        drawingActive = false;
        document.getElementById('myCanvas').style.cursor = 'default';
    }
}
    

function onMouseUp(event) {
    // Stop dragging when the mouse button is released
    if (active_spi) {
        active_spi.dragging = false;
        active_spi = null;
    }
    if (draggingPoint) {
        draggingPoint = null; // stop dragging string
    }
}

var detect = false; // switch for turning on and off spline node proximity detection
function onMouseMove(event) {
    // Check if the mouse is over the green initial circle
    if (Z_spi_init.contains(event.point)) {
        if (!Z_spi_selected) {
            Z_spi_init.strokeColor = black_color_h;
            Z_spi_init.strokeWidth = 3;
            Z_spi_plus.visible = true; // Show the plus symbol
            Z_spi_selected = true;
        }
    } else {
        if (Z_spi_selected) {
            Z_spi_init.strokeColor = black_color;
            Z_spi_init.strokeWidth = 2;
            Z_spi_plus.visible = false; // Hide the plus symbol
            Z_spi_selected = false;
        }
    }

    // Check if the mouse is over the red initial circle
    if (X_spi_init.contains(event.point)) {
        if (!X_spi_selected) {
            X_spi_init.strokeColor = black_color_h;
            X_spi_init.strokeWidth = 3;
            X_spi_plus.visible = true; // Show the plus symbol
            X_spi_selected = true;
        }
    } else {
        if (X_spi_selected) {
            X_spi_init.strokeColor = black_color;
            X_spi_init.strokeWidth = 2;
            X_spi_plus.visible = false; // Hide the plus symbol
            X_spi_selected = false;
        }
    }
    // for creating strings
    if (drawingActive && activePath) {
        activePath.add(event.point);
    }
    
    // showing the spline points when mouse is ontop of strings
    for (var i = 0; i < splines_points.length; i++) {
        for (var j = 0; j < splines_points[i].length; j++) {
            var distance = event.point.getDistance(splines_points[i][j].position);
            if (distance <= 6 || strings[i].hitTest(event.point)) {
                for (var k = 0; k < splines_points[i].length; k++) {
                     splines_points[i][k].visible = true;
                }
                detect = true;
                break;

            } else {
                for (var k = 0; k < splines_points[i].length; k++) {
                     splines_points[i][k].visible = false;
                }
            }
            
        }
    }
    // mouse to hand
    var hitResult = project.activeLayer.hitTest(event.point);
    if (hitResult) {
        // If the mouse is over an object, change the cursor to a hand (pointer)
        document.getElementById('myCanvas').style.cursor = 'pointer';
    } else {
        if (drawingActive) {
            document.getElementById('myCanvas').style.cursor = 'crosshair';
        } else {
            document.getElementById('myCanvas').style.cursor = 'default';
        }
    }
}

// Function to snap a point to the nearest grid intersection
function snapToGrid(point) {
    return new Point(
        Math.round((point.x-view.center.x)/ gridSize ) * gridSize + view.center.x - 10,
        Math.round((point.y-view.center.y)/ gridSize) * gridSize + view.center.y - 10
    );
}

// Setup event listeners
view.on('mousedown', onMouseDown);
view.on('mousemove', onMouseMove);
view.on('mousedrag', onMouseDrag);
view.on('mouseup', onMouseUp);

// Initial setup
createGridDots();



</script>
</head>
<body>
    
    <canvas id="myCanvas" resize></canvas>
    
</body>
</html>
